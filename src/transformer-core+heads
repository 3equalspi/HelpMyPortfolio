using Flux
using Flux: Dense, gelu, sigmoid, softmax, LayerNorm, params

# ---------- helpers: apply Dense/LayerNorm along the last dimension ----------
# x_bsd is (B, S, D_in). Dense expects (D_in, N), so we reshape.
function apply_dense_time(d::Dense, x_bsd::AbstractArray)
    B, S, Din = size(x_bsd)
    X = reshape(permutedims(x_bsd, (3, 2, 1)), Din, S * B)         # (Din, S*B)
    Y = d(X)                                                        # (Dout, S*B)
    Dout = size(Y, 1)
    return permutedims(reshape(Y, (Dout, S, B)), (3, 2, 1))         # (B, S, Dout)
end

function apply_layernorm_time(ln::LayerNorm, x_bsd::AbstractArray)
    B, S, D = size(x_bsd)
    X = reshape(permutedims(x_bsd, (3, 2, 1)), D, S * B)            # (D, S*B)
    Y = ln(X)                                                        # (D, S*B)
    return permutedims(reshape(Y, (D, S, B)), (3, 2, 1))             # (B, S, D)
end

# ---------- Multi-Head Self-Attention ----------
struct MyMHA
    Wq::Dense
    Wk::Dense
    Wv::Dense
    Wo::Dense
    n_heads::Int
    head_dim::Int
end
Flux.@functor MyMHA

function MyMHA(d_model::Int, n_heads::Int)
    @assert d_model % n_heads == 0 "d_model must be divisible by n_heads"
    hd = div(d_model, n_heads)
    MyMHA(Dense(d_model, d_model), Dense(d_model, d_model),
          Dense(d_model, d_model), Dense(d_model, d_model), n_heads, hd)
end

function (m::MyMHA)(x::AbstractArray)  # x: (B, S, D)
    q = apply_dense_time(m.Wq, x)
    k = apply_dense_time(m.Wk, x)
    v = apply_dense_time(m.Wv, x)

    B, S, D = size(q)
    H, hd = m.n_heads, m.head_dim

    # reshape to (B, H, S, hd)
    Q = permutedims(reshape(q, B, S, H, hd), (1, 3, 2, 4))
    K = permutedims(reshape(k, B, S, H, hd), (1, 3, 2, 4))
    V = permutedims(reshape(v, B, S, H, hd), (1, 3, 2, 4))

    Z = Array{eltype(x)}(undef, B, S, H * hd)  # output per token before Wo

    inv_sqrt_hd = 1f0 / sqrt(Float32(hd))
    @inbounds for b in 1:B
        for h in 1:H
            Qi = reshape(@view(Q[b, h, :, :]), S, hd)
            Ki = reshape(@view(K[b, h, :, :]), S, hd)
            Vi = reshape(@view(V[b, h, :, :]), S, hd)

            scores = (Qi * Ki') .* inv_sqrt_hd                   # (S, S)
            A = softmax(scores; dims=2)                          # row-wise queries over keys
            Zi = A * Vi                                          # (S, hd)

            @view(Z[b, :, (h-1)*hd + 1:h*hd]) .= Zi
        end
    end

    # output projection
    return apply_dense_time(m.Wo, Z)  # (B, S, D)
end

# ---------- Encoder Block ----------
struct EncoderBlock
    mha::MyMHA
    ln1::LayerNorm
    ff1::Dense
    ff2::Dense
    ln2::LayerNorm
end
Flux.@functor EncoderBlock

function EncoderBlock(d_model::Int; ff_mult::Int=4, n_heads::Int=8)
    EncoderBlock(
        MyMHA(d_model, n_heads),
        LayerNorm(d_model),
        Dense(d_model, ff_mult * d_model),
        Dense(ff_mult * d_model, d_model),
        LayerNorm(d_model),
    )
end

function (eb::EncoderBlock)(x::AbstractArray)  # x: (B, S, D)
    # Self-attention + residual + norm
    y = x .+ eb.mha(x)
    y = apply_layernorm_time(eb.ln1, y)

    # FFN (time-distributed) + residual + norm
    h = gelu.(apply_dense_time(eb.ff1, y))
    h = apply_dense_time(eb.ff2, h)
    z = y .+ h
    return apply_layernorm_time(eb.ln2, z)
end

# ---------- Full Encoder-only Transformer with 3 heads ----------
struct FinancialTransformer
    blocks::Vector{EncoderBlock}
    # heads operate on last-timestep representation
    price_head::Dense
    direction_head::Dense
    vol_head::Dense
end
Flux.@functor FinancialTransformer

function FinancialTransformer(; d_model=256, n_layers=6, n_heads=8, ff_mult=4)
    blocks = [EncoderBlock(d_model; ff_mult=ff_mult, n_heads=n_heads) for _ in 1:n_layers]
    FinancialTransformer(
        blocks,
        Dense(d_model, 1),      #price change %
        Dense(d_model, 1),      #up/down logit
        Dense(d_model, 1),      #volatility (softplus later)
    )
end

#Forward: (B, S, D) -> (B, 3) = [price_change, direction_prob, volatility]
function (m::FinancialTransformer)(x::AbstractArray)
    x32 = Float32.(x)

    y = x32
    for blk in m.blocks
        y = blk(y)
    end

    # Aggregate last timestep (e.g., day 30): (B, D)
    last = @view y[:, end, :]                           # (B, D)
    D = size(last, 2)
    T = permutedims(last, (2, 1))                       # (D, B) for Dense

    price       = m.price_head(T)                       # (1, B)
    direction   = sigmoid.(m.direction_head(T))         # (1, B) in (0,1)
    volatility  = Flux.softplus.(m.vol_head(T))         # (1, B) >= 0

    # Back to (B, 3)
    return hcat(permutedims(price, (2, 1)),
                permutedims(direction, (2, 1)),
                permutedims(volatility, (2, 1)))        # (B, 3)
end
