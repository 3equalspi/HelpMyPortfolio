#FORWARD PASS
function financial_transformer_loss(y_pred, y_true, prices; 
                                   weights=[0.3, 0.4, 0.2, 0.1],
                                   risk_free_rate=0.02,
                                   asymmetric_penalty=2.0)
    
    N = size(y_pred, 1)
    
    #Predict the components
    pred_price_change = y_pred[:, 1]
    pred_direction_prob = y_pred[:, 2]  # Probability of positive movement
    pred_volatility = y_pred[:, 3]
    
    true_price_change = y_true[:, 1]
    true_direction = y_true[:, 2]  # 1 for up, 0 for down
    true_volatility = y_true[:, 3]
    
    #Entropy
    ϵ = 1e-8
    pred_direction_prob = clamp.(pred_direction_prob, ϵ, 1 - ϵ)
    
    direction_loss = -mean(true_direction .* log.(pred_direction_prob) .+ 
                          (1 .- true_direction) .* log.(1 .- pred_direction_prob))
    
    price_errors = pred_price_change .- true_price_change
    
    asymmetric_weights = ifelse.(price_errors .> 0, 1.0, asymmetric_penalty)
    
    huber_delta = 0.01  
    magnitude_loss = mean(asymmetric_weights .* 
                         ifelse.(abs.(price_errors) .<= huber_delta,
                                0.5 .* price_errors.^2,
                                huber_delta .* (abs.(price_errors) .- 0.5 * huber_delta)))
    
    if length(prices) > 1
        returns = diff(log.(prices))
        if std(returns) > 1e-8
            sharpe_ratio = (mean(returns) - risk_free_rate/252) / std(returns))
            risk_loss = max(0, 1 - sharpe_ratio)
        else
            risk_loss = 1.0
        end
    else
        risk_loss = 0.0
    end

    vol_errors = pred_volatility .- true_volatility
    
    time_weights = exp.(-0.1 * (N:-1:1))
    time_weights = time_weights ./ sum(time_weights)  #normalize
    
    volatility_loss = sum(time_weights .* vol_errors.^2)
    

    price_change_magnitude = abs.(true_price_change)
    regime_threshold = quantile(price_change_magnitude, 0.95)  #Top 5% moves
    
    regime_events = price_change_magnitude .> regime_threshold
    if any(regime_events)
        regime_errors = abs.(price_errors[regime_events])
        regime_penalty = mean(regime_errors) * 2.0  #Extra penalty for missing big moves
    else
        regime_penalty = 0.0
    end
    
    total_loss = (weights[1] * direction_loss + 
                  weights[2] * magnitude_loss + 
                  weights[3] * risk_loss + 
                  weights[4] * volatility_loss + 
                  0.1 * regime_penalty) 
    
    return total_loss, Dict(
        "direction_loss" => direction_loss,
        "magnitude_loss" => magnitude_loss, 
        "risk_loss" => risk_loss,
        "volatility_loss" => volatility_loss,
        "regime_penalty" => regime_penalty,
        "total_loss" => total_loss
    )
end


 
#BACKWARD PASS
function financial_loss_gradient(y_pred, y_true, prices; 
                                weights=[0.3, 0.4, 0.2, 0.1],
                                asymmetric_penalty=2.0)
    
    N = size(y_pred, 1)
    grad = zeros(size(y_pred))
    
    #extract components
    pred_price_change = y_pred[:, 1]
    pred_direction_prob = y_pred[:, 2]
    pred_volatility = y_pred[:, 3]
    
    true_price_change = y_true[:, 1]
    true_direction = y_true[:, 2]
    true_volatility = y_true[:, 3]
    
    ϵ = 1e-8
    pred_direction_prob = clamp.(pred_direction_prob, ϵ, 1 - ϵ)
    
    grad[:, 2] = weights[1] * (-true_direction ./ pred_direction_prob .+ 
                              (1 .- true_direction) ./ (1 .- pred_direction_prob)) / N
    
    price_errors = pred_price_change .- true_price_change
    asymmetric_weights = ifelse.(price_errors .> 0, 1.0, asymmetric_penalty)
    
    huber_delta = 0.01
    huber_grad = ifelse.(abs.(price_errors) .<= huber_delta,
                        price_errors,
                        huber_delta .* sign.(price_errors))
    
    grad[:, 1] = weights[2] * asymmetric_weights .* huber_grad / N
    
    vol_errors = pred_volatility .- true_volatility
    time_weights = exp.(-0.1 * (N:-1:1))
    time_weights = time_weights ./ sum(time_weights)
    
    grad[:, 3] = weights[4] * 2 .* time_weights .* vol_errors
    
    # Add Sharpe ratio gradient if prices provided and length > 1.
    #dont know if the code below is sigma
    if length(prices) > 1
        returns = diff(log.(prices))
        if std(returns) > 1e-8
            mean_return = mean(returns)
            std_return = std(returns)
            
            # Gradient of Sharpe ratio w.r.t. each return
            # ∂Sharpe/∂r_i = (1/std - (mean-rf)/(std^3)) * (r_i - mean) / n
            sharpe_grad_returns = (1/std_return .- 
                                  (mean_return - 0.02/252) / (std_return^3) .* 
                                  (returns .- mean_return)) ./ length(returns)
            
            # Convert return gradients to price change gradients
            # Since returns ≈ price_changes for small changes
            if length(sharpe_grad_returns) == N
                grad[:, 1] += weights[3] * sharpe_grad_returns
            end
        end
    end
    
    return grad
end